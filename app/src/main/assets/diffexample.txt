diff --git a/fixtures/markdown.html b/fixtures/markdown.html
new file mode 100644
index 0000000..02f5b9f
--- /dev/null
+++ b/fixtures/markdown.html
@@ -0,0 +1,5 @@
+<p>Hello world 
+    <a href="https://github.com/github/linguist/issues/1" class="issue-link" title="Binary detection issues on extensionless files">github/linguist#1</a>
+    <strong>cool</strong>, and 
+    <a href="https://github.com/gollum/gollum/issues/1" class="issue-link" title="no method to write a file?">#1</a>!
+</p>
\ No newline at end of file
diff --git a/fixtures/markdown_raw.html b/fixtures/markdown_raw.html
new file mode 100644
index 0000000..2cb4963
--- /dev/null
+++ b/fixtures/markdown_raw.html
@@ -0,0 +1,3 @@
+<p>Hello world github/linguist#1 
+    <strong>cool</strong>, and #1!
+</p>
\ No newline at end of file
diff --git a/octokit/markdown.go b/octokit/markdown.go
new file mode 100644
index 0000000..0efb34a
--- /dev/null
+++ b/octokit/markdown.go
@@ -0,0 +1,45 @@
+package octokit
+
+// MardownURL is for rendering an arbitrary markdown document
+// MarkdownRawURL is for rendering raw markdown
+var (
+	MarkdownURL    = Hyperlink("/markdown")
+	MarkdownRawURL = Hyperlink("/markdown/raw")
+)
+
+// Create a MarkdownService
+func (c *Client) Markdown() (m *MarkdownService) {
+	m = &MarkdownService{client: c}
+	return
+}
+
+// A service to return HTML rendered markdown document
+type MarkdownService struct {
+	client *Client
+}
+
+// Renders a markdown document with json input
+func (m *MarkdownService) Render(uri *Hyperlink, requestParams interface{}) (renderedHTML string, result *Result) {
+	url, err := ExpandWithDefault(uri, &MarkdownURL, nil)
+	if err != nil {
+		return "", &Result{Err: err}
+	}
+	result = sendRequest(m.client, url, func(req *Request) (*Response, error) {
+		req.setBody(requestParams)
+		return req.createResponseRaw(req.Request.Post(), &renderedHTML)
+	})
+	return
+}
+
+// Renders a markdown document with string input
+func (m *MarkdownService) RenderRaw(uri *Hyperlink, markdownText *string) (renderedHTML string, result *Result) {
+	url, err := ExpandWithDefault(uri, &MarkdownURL, nil)
+	if err != nil {
+		return "", &Result{Err: err}
+	}
+	result = sendRequest(m.client, url, func(req *Request) (*Response, error) {
+		req.setBodyText(markdownText)
+		return req.createResponseRaw(req.Request.Post(), &renderedHTML)
+	})
+	return
+}
diff --git a/octokit/markdown_test.go b/octokit/markdown_test.go
new file mode 100644
index 0000000..9b324cf
--- /dev/null
+++ b/octokit/markdown_test.go
@@ -0,0 +1,68 @@
+package octokit
+
+import (
+	"net/http"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestMarkdownService_JSON(t *testing.T) {
+	setup()
+	defer tearDown()
+
+	mux.HandleFunc("/markdown", func(w http.ResponseWriter, r *http.Request) {
+		testMethod(t, r, "POST")
+		testBody(t, r, "{\"context\":\"github/gollum\",\"mode\":\"gfm\",\"text\":\"Hello world github/linguist#1 **cool**, and #1!\"}\n")
+
+		respondWith(w, loadFixture("markdown.html"))
+	})
+
+	input := M{
+		"text":    "Hello world github/linguist#1 **cool**, and #1!",
+		"mode":    "gfm",
+		"context": "github/gollum",
+	}
+
+	markdown, result := client.Markdown().Render(nil, input)
+	assert.False(t, result.HasError())
+
+	expected := "<p>Hello world \n" +
+		"    <a href=\"https://github.com/github/linguist/issues/1\" class=\"issue-link\" title=\"Binary detection issues on extensionless files\">github/linguist#1</a>\n" +
+		"    <strong>cool</strong>, and \n" +
+		"    <a href=\"https://github.com/gollum/gollum/issues/1\" class=\"issue-link\" title=\"no method to write a file?\">#1</a>!\n" +
+		"</p>"
+	assert.Equal(t, expected, markdown)
+}
+
+func TestMarkdownService_RAW(t *testing.T) {
+	setup()
+	defer tearDown()
+
+	mux.HandleFunc("/markdown/raw", func(w http.ResponseWriter, r *http.Request) {
+		testMethod(t, r, "POST")
+		testBody(t, r, "Hello world github/linguist#1 **cool**, and #1!")
+
+		respondWith(w, loadFixture("markdown_raw.html"))
+	})
+
+	input := "Hello world github/linguist#1 **cool**, and #1!"
+
+	markdown, result := client.Markdown().RenderRaw(&MarkdownRawURL, &input)
+	assert.False(t, result.HasError())
+
+	expected := "<p>Hello world github/linguist#1 \n" +
+		"    <strong>cool</strong>, and #1!\n" +
+		"</p>"
+	assert.Equal(t, expected, markdown)
+}
+
+func TestMarkdownService_Failure(t *testing.T) {
+	setup()
+	defer tearDown()
+
+	url := Hyperlink("}")
+	markdown, result := client.Markdown().Render(&url, nil)
+	assert.True(t, result.HasError())
+	assert.Empty(t, markdown)
+}
diff --git a/octokit/request.go b/octokit/request.go
index 5cd0250..330f12d 100644
--- a/octokit/request.go
+++ b/octokit/request.go
@@ -1,8 +1,10 @@
 package octokit
 
 import (
+	"bytes"
 	"github.com/jingweno/go-sawyer"
 	"github.com/jingweno/go-sawyer/mediatype"
+	"io/ioutil"
 )
 
 func newRequest(client *Client, urlStr string) (req *Request, err error) {
@@ -74,6 +76,14 @@ func (r *Request) setBody(input interface{}) {
 	r.Request.SetBody(mtype, input)
 }
 
+func (r *Request) setBodyText(input *string) {
+	mtype, _ := mediatype.Parse(textMediaType)
+	buf := bytes.NewBufferString(*input)
+	r.Header.Set("Content-Type", mtype.String())
+	r.ContentLength = int64(buf.Len())
+	r.Body = ioutil.NopCloser(buf)
+}
+
 func (r *Request) createResponse(sawyerResp *sawyer.Response, output interface{}) (resp *Response, err error) {
 	resp, err = NewResponse(sawyerResp)
 	if err == nil {
@@ -82,3 +92,13 @@ func (r *Request) createResponse(sawyerResp *sawyer.Response, output interface{}
 
 	return
 }
+
+func (r *Request) createResponseRaw(sawyerResp *sawyer.Response, output *string) (resp *Response, err error) {
+	resp, err = NewResponse(sawyerResp)
+	body, err := ioutil.ReadAll(resp.Body)
+	if err != nil {
+		return resp, err
+	}
+	*output = string(body)
+	return
+}